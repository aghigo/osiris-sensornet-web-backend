package br.uff.labtempo.osiris.generator;

import br.uff.labtempo.omcp.common.exceptions.AbstractRequestException;
import br.uff.labtempo.omcp.common.exceptions.InternalServerErrorException;
import br.uff.labtempo.osiris.repository.FunctionRepository;
import br.uff.labtempo.osiris.repository.LinkRepository;
import br.uff.labtempo.osiris.to.common.data.FieldTo;
import br.uff.labtempo.osiris.to.common.definitions.FunctionOperation;
import br.uff.labtempo.osiris.to.virtualsensornet.BlendingVsnTo;
import br.uff.labtempo.osiris.to.virtualsensornet.FunctionVsnTo;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.UUID;

/**
 * Class responsible to generate random Blending sensors for VirtualSensorNet module
 * @see BlendingVsnTo
 * @author andre.ghigo
 * @since 1.8
 * @version 1.0
 */
public class BlendingGenerator {

    private final int CALL_INTERVAL_INMILLIS_MAX_RANGE = 99999;
    private FunctionOperation[] functionOperationArray = FunctionOperation.values();

    @Autowired
    private FunctionRepository functionRepository;

    @Autowired
    private LinkRepository linkRepository;

    /**
     * Generates a random Blending sensor mocked object
     * @see BlendingVsnTo
     * @return BlendingVsnTo
     * @throws AbstractRequestException
     */
    public BlendingVsnTo generateBlendingVsnTo() throws AbstractRequestException {
        long id = getId();
        String label = getLabel(id);
        BlendingVsnTo blendingVsnTo = new BlendingVsnTo(id, label);
        blendingVsnTo.setCallIntervalInMillis(getCallIntervalInMillis());
        FunctionVsnTo functionVsnTo = getFunction();
        blendingVsnTo.setFunction(functionVsnTo);
        blendingVsnTo.setCallMode(getFunctionOperation());
        List<FieldTo> fieldToList = getFieldToList();
        for(FieldTo fieldTo : fieldToList) {
            blendingVsnTo.addRequestParam(fieldTo.getId(), fieldTo.getName());
        }
        blendingVsnTo.addResponseParam(fieldToList.get(0).getId(), functionVsnTo.getName());
        return blendingVsnTo;
    }

    /**
     * Generate a random unique long id for the Blending
     * @see UUID
     * @see Long
     * @return long Blending id
     */
    private long getId() {
        return UUID.randomUUID().getMostSignificantBits() & Long.MAX_VALUE;
    }

    /**
     * Generate a random unique Blending Label
     * Pattern: "blendingId-" + id, where id is generated by getId()
     * @param id
     * @return String with Blending Label
     */
    private String getLabel(long id) {
        return "blendingId-" + id;
    }

    /**
     * Randomly choose one Function randomly from the VirtualSensorNet module
     * @return FunctionVsnTo
     * @throws AbstractRequestException
     */
    private FunctionVsnTo getFunction() throws AbstractRequestException {
        List<FunctionVsnTo> functionVsnToList = this.functionRepository.getAll();
        if(functionVsnToList == null || functionVsnToList.isEmpty()) {
            throw new InternalServerErrorException("Failed to mock Blending Sensor: could not find any function.");
        }
        int p = (int) (Math.random() * functionVsnToList.size());
        return functionVsnToList.get(p);
    }

    /**
     * Randomly choose a FunctionOperation
     * Enum = SYNCHRONOUS | ASYNCHRONOUS
     * @see FunctionOperation
     * @return FunctionOperation
     */
    private FunctionOperation getFunctionOperation() {
        int p = (int) (Math.random() * this.functionOperationArray.length);
        return this.functionOperationArray[p];
    }

    /**
     * Get a random long value that represents blending callIntervalInMillis,
     * respecting the range: from 0 to CALL_INTERVAL_INMILLIS_MAX_RANGE.
     * @return long
     */
    private long getCallIntervalInMillis() {
        return (long) (Math.random() * CALL_INTERVAL_INMILLIS_MAX_RANGE);
    }

    /**
     * Return a random list of virtualsensor fields
     * A Field contains its Id and an associated DataType id
     * @see FieldTo
     * @see br.uff.labtempo.osiris.to.virtualsensornet.DataTypeVsnTo
     * @return
     * @throws AbstractRequestException
     */
    private List<FieldTo> getFieldToList() throws AbstractRequestException {
        List<FieldTo> fieldToList = this.linkRepository.getAllFields();
        if(fieldToList == null || fieldToList.isEmpty()) {
            throw new InternalServerErrorException("Failed to mock Blending Sensor: could not find any Field for Request Params.");
        }
        int min = (int) (Math.random() * fieldToList.size());
        int max = min + (int) (Math.random() * (fieldToList.size() - min));
        return fieldToList.subList(min, max);
    }
}
